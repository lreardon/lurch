{"version":3,"sources":["xml-groups.litcoffee"],"names":["allowedChildrenProblems","isGroupRight","markGroupRight","markGroupWrong","tagData","hasProp","hasOwnProperty","window","setTagData","newData","addTagData","key","results","value","pluginsToLoad","setGroupTag","group","tagName","set","getGroupTag","get","initializeGroupTag","parentTagName","parent","topLevelTagName","getTagData","ref","Group","getTagExternalName","topLevel","XMLMenuItems","allowed","documentation","external","parentTag","result","tag","replace","push","text","onclick","tinymce","activeEditor","Dialogs","alert","title","message","xml","convertToXML","width","menu","i","len","Object","keys","sort","length","disabled","groupToolbarButtons","viewxml","tooltip","doExport","editor","id","problems","Groups","ids","concat","height","confirm","join","okCallback","XMLGroupChanged","firstTime","setTimeout","validateHierarchy","XMLGroupDeleted","children","plugin","clear","reason","b","belongsAfter","belongsIn","bnames","check","gname","groupTag","moreProblems","next","phrase","pname","prevTag","walk","Array","indexOf","call","previousSibling","nextSibling","subject","child","childTag","count","counts","max","min","verb","word","alterXML","indent","inner","range","shouldBreak","withBreaksAndTabs","wrap","wrapper","node","nodeOrList","index","tmp","cloneContents","document","createElement","appendChild","console","log","nodeType","textContent","childNodes","RegExp","rangeBefore","test","toString","rangeAfter","contentAsFragment","getContent","format","DOM","encode","contentAsHTML"],"mappings":"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","file":"xml-groups.js","sourcesContent":["\n# XML Groups Module\n\nThis module lets the client convert the contents of a TinyMCE editor (with\n[the Groups plugin](../app/groupsplugin.litcoffee) enabled) into XML, and to\ncheck first whether the structure of the groups in the document satisfies\ncertain criteria (so that the resulting XML will be valid).\n\n## Tag Data\n\nClients of this module will specify which XML tags are relevant to their\nparticular application, and how we should go about validating their\nstructure.  We provide the `setTagData` and `addTagData` functions, each of\nwhich takes one argument, a mapping from tag names to objects that give the\nproperties of the named tag.\n\nThe following properties are supported for each tag name.\n * `topLevel` - true if and only if the document itself is to be treated as\n   a Group with this tag.  There should be exactly one tag with this\n   attribute set to true.\n * `defaultChild` - the tag name that children should have by default.  When\n   a new Group is inserted into the document, its parent Group will be\n   queried for its `defaultChild` property, and that value used to set the\n   tag of the new group.  If the new group has no parent, then the\n   `defaultChild` property of the `topLevel` tag is used.\n * `externalName` - a human-readable name to be used in the user interface\n   when mentioning this tag, for example \"widgetNum\" might have the external\n   name \"Widget Number.\"  This is useful for populating bubble tags, for\n   instance.  See the `getExternalTagName` function\n   [below](#querying-tag-data).\n * `documentation` - an HTML string (possibly lengthy) describing the tag's\n   purpose from the end user's point of view.  This module places on the\n   groups' tag and context menus an option for reading this documentation in\n   a popup window.\n * `includeText` - This impacts how the XML representation of a group with\n   the tag in question is computed.\n   * If this attribute is true, then the XML will include, between inner\n     elements, any text that appears between those elements' groups in the\n     document.\n   * If this attribute is a string containing the name of another tag, then\n     the text will be included and will be wrapped in an element with that\n     tag name.\n   * If this attribute is false (or any value that doesn't fit either of the\n     previous two cases), then any text between inner groups is ignored.\n   * The default is true for leaves in the group hierarchy, and false for\n     non-leaf groups.\n * `alterXML` - If this key is provided, its value should be a function\n   taking two parameters, a string and a Group.  The string will contain the\n   XML generated from the Group, and this function is free to alter that XML\n   as it sees fit, returning the (optionally changed) result, before it gets\n   returned from the recursive XML-generating procedure.\n * `belongsIn` - the value should be an array of strings, each the name of a\n   tag in which groups of this tag type can sit, as children.  Any gruop of\n   this tag type will be marked invalid if it sits inside a group whose tag\n   type is not on this list.  (See [validation](#validating-the-hierarchy).)\n   A group automatically satisfies this requirement if it has no\n   \"belongsIn\" data set for it.\n * `belongsAfter` - Functions exactly like \"belongsIn\" except examines the\n   previous sibling rather than the parent.  The only difference is that not\n   every group has a previous sibling, whereas all have a parent given that\n   the document counts as a parent.  Thus if a group has \"belongsAfter\"\n   defined but no previous sibling, it satisfies this requirement if and\n   only if `null` appears on the \"belongsAfter\" list.\n * `unique` - if true, this indicates that only one group with this tag can\n   exist in any given parent group.  Any others will be flagged as invalid\n   by the validation routine.  (See\n   [validation](#validating-the-hierarchy).)\n * `allowedChildren` - if present, this should be a mapping from names of\n   other tags to intervals [min,max] of permitted number of occurrences of\n   them as children of elements with this tag.  For instance, the Employee\n   tag might have an \"allowedChildren\" map of\n   `Client : [0,999999999], Gender : [1,1]`, which indicates that there can\n   be any number of Client elements for an Employee, but only one Gender.\n   This will be checked at validation time.  (See\n   [validation](#validating-the-hierarchy).)  Also, the set of permitted\n   child elements will be used to restrict the menu when the user attempts\n   to change the type of a child; only permitted types will be active.\n * `contentCheck` - If present, this should be a function that will be run\n   last in any validation of the group.  It should return an array of error\n   strings describing zero or more ways the group failed to validate.  If\n   the group passes validation, return an empty array.  If absent, no custom\n   validation will be done; only the criteria described above will be\n   applied.  If present, this function can do whatever additional custom\n   validation of the document hierarchy you need.  (See\n   [validation](#validating-the-hierarchy).)\n * `rawXML` - If true, this attribute means that the content of the element\n   should be passed into the XML encoding raw, without being escaped.  Use\n   this when you anticipate actually typing XML code into a group in the\n   document, and you want that XML transferred directly to the XML encoding.\n\n    tagData = { }\n    window.setTagData = ( newData ) -> tagData = newData\n    window.addTagData = ( newData ) ->\n        tagData[key] = value for own key, value of newData\n\nUse the Dialogs plugin.\n\n    window.pluginsToLoad = [ 'dialogs' ]\n\n## Tagging Groups\n\nYou can set the tag name for a Group object, and query it as well, with the\nfollowing two functions.  They simply use the \"tagName\" attribute of the\nGroup object.\n\n    window.setGroupTag = ( group, tagName ) -> group.set 'tagName', tagName\n    window.getGroupTag = ( group ) -> group.get 'tagName'\n\nTo tag a Group with its appropriate default tag name, based on its parent's\ntag name, call the following function.\n\n    window.initializeGroupTag = ( group ) ->\n        parentTagName = if group.parent\n            window.getGroupTag group.parent\n        else\n            window.topLevelTagName()\n        tagName = window.getTagData parentTagName, 'defaultChild'\n        if tagName then window.setGroupTag group, tagName\n\n## Querying Tag Data\n\nClients can query the data in that object at a primitive level with\n`getTagData`.  More specialized query functions follow.\n\nIf a group is given as the first parameter, its tag name is extracted.\n\n    window.getTagData = ( tagName, key ) ->\n        if tagName instanceof window.Group\n            tagName = window.getGroupTag tagName\n        tagData[tagName]?[key]\n\nThis function queries the official name associated with the given tag name.\nIf it has an \"externalName,\" then that is returned.  Otherwise the given tag\nname is returned unchanged.\n\nIf a group is given as the first parameter, its tag name is extracted.\n\n    window.getTagExternalName = ( tagName ) ->\n        if tagName instanceof window.Group\n            tagName = window.getGroupTag tagName\n        window.getTagData( tagName, 'externalName' ) ? tagName\n\nThis function locates the one tag name that has the attribute `topLevel` set\nto true.  (Technically it locates the first, in the arbitrary order of keys\ngiven by the `tagData` object internally, but since there should be only one\nsuch tag name, that means the same thing.)\n\n    window.topLevelTagName = ->\n        for own key, value of tagData\n            if value.topLevel then return key\n\nThis function creates a set of menu items for the given group.  Specifics\nare documented within the code below.\n\n    window.XMLMenuItems = ( group ) ->\n        result = [ ]\n\nFirst, check to see if the given group has any documentation, and if it\ndoes, add to the given array of TinyMCE menu items an item for querying the\ngroup's documentation.  If it has none, do nothing.\n\n        if ( tag = window.getGroupTag group )?\n            external = window.getTagExternalName tag\n            if ( documentation = window.getTagData tag, 'documentation' )?\n                documentation = documentation.replace /a href=/g,\n                    'a target=\"_blank\" href='\n                result.push\n                    text : \"Read \\\"#{external}\\\" documentation\"\n                    onclick : ->\n                        tinymce.activeEditor.Dialogs.alert\n                            title : \"Documentation for \\\"#{external}\\\"\"\n                            message : documentation\n\nCreate a menu item for seeing the XML code representing the given group.\n\n        result.push\n            text : \"View XML representation\"\n            onclick : ->\n                xml = window.convertToXML group\n                    .replace /&/g, '&amp;'\n                    .replace /</g, '&lt;'\n                tinymce.activeEditor.Dialogs.alert\n                    title : 'XML Representation'\n                    width : 600\n                    message : \"\"\"\n                        <html>\n                            <head>\n                                <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css\">\n                                <script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n                            </head>\n                            <body>\n                                <pre><code class='xml'>#{xml}</code></pre>\n                                <script>hljs.initHighlightingOnLoad();</script>\n                            </body>\n                        </html>\"\"\"\n\nCreate a submenu for changing the tag of this group.\n\n        parentTag = if group.parent then window.getGroupTag group.parent \\\n            else window.topLevelTagName()\n        allowed = window.getTagData parentTag, 'allowedChildren'\n        result.push\n            text : 'Change tag to...'\n            menu : for tagName in Object.keys( tagData ).sort()\n                do ( tagName ) ->\n                    text : window.getTagExternalName tagName\n                    disabled : allowed? and tagName not of allowed\n                    onclick : -> group.set 'tagName', tagName\n\nReturn the full list of menu items we generated.\n\n        result\n\n## Define one toolbar button\n\nThis toolbar button is for viewing the XML representation of the entire\ndocument in a new tab.\n\n    window.groupToolbarButtons =\n        viewxml :\n            text : 'XML'\n            tooltip : 'View XML representation of this document'\n            onclick : ->\n                problems = [ ]\n                editor = tinymce.activeEditor\n                for id in editor.Groups.ids()\n                    if not isGroupRight editor.Groups[id]\n                        problems.push 'At least one element in your document\n                            has errors (indicated by a red X following the\n                            element).'\n                        break\n                allowed = window.getTagData window.topLevelTagName(),\n                    'allowedChildren'\n                if allowed\n                    problems = problems.concat \\\n                        allowedChildrenProblems editor.Groups.topLevel,\n                            allowed, 'document'\n                doExport = ->\n                    xml = window.convertToXML()\n                        .replace /&/g, '&amp;'\n                        .replace /</g, '&lt;'\n                        .replace />/g, '&gt;'\n                    tinymce.activeEditor.Dialogs.alert\n                        title : 'XML Representation'\n                        width : 800\n                        height : 600\n                        message : \"\"\"\n                            <html>\n                                <head>\n                                    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css\">\n                                    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n                                </head>\n                                <body>\n                                    <pre><code class='xml'>#{xml}</code></pre>\n                                    <script>hljs.initHighlightingOnLoad();</script>\n                                </body>\n                            </html>\"\"\"\n                if problems.length is 0 then return doExport()\n                tinymce.activeEditor.Dialogs.confirm\n                    title : 'Problems with your document'\n                    message : \"<p><b>The problems listed below exist in your\n                    document.</b></p>\n                    <ul><li>#{problems.join '</li><li>'}</li></ul>\n                    <p>You can click OK to generate XML anyway, but\n                    it may be invalid.  Click Cancel to go back and fix\n                    these problems first.</b></p>\"\n                    okCallback : doExport\n\n## Provide generic event handlers\n\nClients will want to install these event handlers in the group types they\ndefine to act as XML elements in their document.  We provide these so that\nthey can easily install them.\n\nThey should set their group's `contentsChanged` handler to this.\n\n    window.XMLGroupChanged = ( group, firstTime ) ->\n\nIf the group has just come into existence, we must check to see what its\ndefault tag type should be, and initialize it to that default.  We must do\nthis on a delay, because when `firstTime` is true, the group does not even\nyet have its parent pointer set.\n\n        if firstTime and not group.get 'tagName'\n            setTimeout ( -> window.initializeGroupTag group ), 0\n\nAnd every time, revalidate the XML hierarchy at this point.\n\n        window.validateHierarchy group\n\nThey should set their group's `deleted` handler to this.\n\n    window.XMLGroupDeleted = ( group ) ->\n\nWe need to revalidate every other child in the same parent.  This will start\nthe chain reaction that does so.\n\n        if group.parent?\n            if group.parent.children[0]\n                window.validateHierarchy group.parent.children[0]\n        else\n            if group.plugin?.topLevel[0]\n                window.validateHierarchy group.plugin.topLevel[0]\n\n## Validating the hierarchy\n\nWe will need three functions, one for marking a group as without problems,\none for marking a group as having problems (with explanations of them), and\none for detecting whether a group has problems.\n\n    markGroupRight = ( group ) ->\n        group.set 'valid', yes\n        group.clear 'closeDecoration'\n        group.clear 'closeHoverText'\n    markGroupWrong = ( group, reason ) ->\n        group.set 'valid', no\n        group.set 'closeDecoration', '<font color=\"red\">&#10006;</font>'\n        group.set 'closeHoverText', reason\n    isGroupRight = ( group ) -> group.get 'valid'\n\nThe following function tests to see if all of the rules specified in the\n`tagData` object are followed by the given group.  Each rule that we must\nvalidate is described individually, interleaved with its corresponding code\nwithin the function.\n\n    window.validateHierarchy = ( group ) ->\n        problems = [ ]\n\nIf the group does not even have a children array, then it probably just\nappeared, and is still being initialized.  In that case, just do validation\nin 100ms isntead of now.\n\n        if not group.children\n            setTimeout ( -> window.validateHierarchy group ), 100\n            return\n\nIf this group does not have a tag name, we cannot even tell if it belongs\nhere or not, and it will create \"undefined\" tags in any XML export.  That is\na problem.\n\n        if not ( groupTag = window.getGroupTag group )?\n            problems.push \"Each element must have a tag, but this one does\n                not.  Add a tag using the context menu.\"\n\nConsider the parent of this group (or the whole document functioning as a\nvirtual parent group for top-level groups).  Is the parent's tag name on the\nlist of valid container tags for this group?\n\n        parentTag = if group.parent then window.getGroupTag group.parent \\\n            else window.topLevelTagName()\n        belongsIn = window.getTagData group, 'belongsIn'\n        if typeof belongsIn is 'string' then belongsIn = [ belongsIn ]\n        if belongsIn instanceof Array and parentTag not in belongsIn\n            gname = window.getTagExternalName group\n            pname = window.getTagExternalName parentTag\n            bnames = ( window.getTagExternalName b for b in belongsIn )\n            pname = if pname then \"#{pname} elements\" \\\n                else \"in an element without a tag\"\n            bnames = ( window.getTagExternalName b for b in belongsIn )\n            phrase = switch bnames.length\n                when 1 then \"this kind of element: #{bnames[0]}\"\n                when 2 then \"these kinds of elements:\n                    #{bnames.join ' and '}\"\n                else \"these kinds of elements: #{bnames.join ', '}\"\n            problems.push \"#{gname} elements are only permitted in\n                #{phrase} (not #{pname}).\"\n\nVery similar check, except for the previous sibling rather than the parent.\n\n        prevTag = if group.previousSibling() then \\\n            window.getGroupTag group.previousSibling() else null\n        belongsAfter = window.getTagData group, 'belongsAfter'\n        if typeof belongsIn is 'string' then belongsAfter = [ belongsAfter ]\n        if belongsAfter is null then belongsAfter = [ null ]\n        if belongsAfter instanceof Array and prevTag not in belongsAfter\n            gname = window.getTagExternalName group\n            pname = window.getTagExternalName prevTag\n            pname = if pname then \"#{pname} elements\" \\\n                else \"being first in their context\"\n            bnames = ( window.getTagExternalName( b ) ? \\\n                \"none (i.e., being the first in their context)\" \\\n                for b in belongsAfter )\n            phrase = switch bnames.length\n                when 1 then \"this kind of element: #{bnames[0]}\"\n                when 2 then \"these kinds of elements:\n                    #{bnames.join ' and '}\"\n                else \"these kinds of elements: #{bnames.join ', '}\"\n            problems.push \"#{gname} elements are only permitted to follow\n                #{phrase} (not #{pname}).\"\n\nIf the group's tag is marked \"unique\" then we must check to see if there are\nany previous siblings with the same tag.  If so, this one is invalid for\nthat reason.\n\n        if window.getTagData group, 'unique'\n            walk = group\n            while walk = walk.previousSibling()\n                if window.getGroupTag( walk ) is groupTag\n                    problems.push \"Each context may contain only one\n                        \\\"#{window.getTagExternalName group}\\\" element.  But\n                        there is already an earlier one in this context,\n                        making this one invalid.\"\n                    break\n\nCheck to see if the group's set of children elements are within the allowed\nnumbers.  To do so, we utilize the auxiliary function\n`allowedChildrenProblems`, which is also used before exporting as XML, to\nensure that the top-level groups satisfy the children requirements of the\nwhole document.\n\n        if allowed = window.getTagData group, 'allowedChildren'\n            problems = problems.concat \\\n                allowedChildrenProblems group.children, allowed\n\nIf the group's tag is marked with a \"contentCheck\" function, we run it now\non the group, to see if it gives us any additional problems.  It returns an\narray of error messages for us to append to the problems array (an empty\narray if it finds no problems).\n\n        if check = window.getTagData group, 'contentCheck'\n            moreProblems = check group\n            if moreProblems instanceof Array\n                problems = problems.concat moreProblems\n\nIf there were any problems, mark the group as invalid.  Otherwise, clear any\nindication of invalidity.\n\n        if problems.length > 0\n            markGroupWrong group, problems.join '\\n'\n        else\n            markGroupRight group\n\nValidating a group happens when some change has taken place that requires\nrevalidation.  Perhaps the tag on this group changed, for instance.  Thus we\nmust also check any later siblings of this group, in case they have the\n\"unique\" attribute, which would could change their validation status based\non attributes of this group.\n\n        if next = group.nextSibling() then window.validateHierarchy next\n\nHere is the auxiliary function used earlier in validating counts of allowed\nchildren.\n\n    allowedChildrenProblems = ( children, allowed, subject = 'element' ) ->\n        problems = [ ]\n\nGet a count of how many children exist with each tag.\n\n        counts = { }\n        for child in children\n            childTag = window.getGroupTag child\n            counts[childTag] ?= 0\n            counts[childTag]++\n        for own tagName of allowed\n            counts[tagName] ?= 0\n\nNow loop through all the counts and see if any violate the restrictions in\n`allowed`.  (Allowed is a mapping of the type described at the top of this\nfile, under the `childrenAllowed` bullet point.)  Any violations generate a\nnew message onto the `problems` array.\n\n        for own tagName, count of counts\n            if not allowed.hasOwnProperty tagName then continue\n            [ min, max ] = allowed[tagName]\n            if not min? or not max? then continue\n            if typeof min isnt 'number' or typeof max isnt 'number'\n                continue\n            verb = if count is 1 then 'is' else 'are'\n            word = if min is 1 then 'child' else 'children'\n            external = window.getTagExternalName tagName\n            if count < min then problems.push \"The #{subject} requires at\n                least #{min} #{word} with tag #{external}, but there\n                #{verb} #{count} in this #{subject}.\"\n            word = if max is 1 then 'child' else 'children'\n            if count > max then problems.push \"The #{subject} permits at\n                most #{max} #{word} with tag #{external}, but there\n                #{verb} #{count} in this #{subject}.\"\n\nReturn the list of problems found.\n\n        problems\n\n## Forming XML\n\nThe following function converts the given group (or the whole document if\nnone is given) into an XML representation using the data in `tagData`.\n\n    window.convertToXML = ( group ) ->\n        if group?\n            children = group.children\n            tag = window.getGroupTag group\n        else\n            children = tinymce.activeEditor.Groups.topLevel\n            tag = window.topLevelTagName()\n        shouldBreak = ( node ) -> node.tagName in [ 'P', 'DIV' ]\n        withBreaksAndTabs = ( nodeOrList ) =>\n            if nodeOrList.cloneContents?\n                tmp = document.createElement 'div'\n                tmp.appendChild nodeOrList.cloneContents()\n                console.log tmp\n                nodeOrList = tmp\n            if nodeOrList?.nodeType is 3 # HTML Text node\n                return nodeOrList.textContent.replace /\\u2003/g, '  '\n            if nodeOrList.tagName is 'BR' then return '\\n'\n            result = ''\n            for index in [0...nodeOrList.childNodes.length]\n                if index > 0 and \\\n                   ( shouldBreak( nodeOrList.childNodes[index-1] ) or \\\n                     shouldBreak( nodeOrList.childNodes[index] ) )\n                    result += '\\n'\n                if index < nodeOrList.childNodes.length - 1 or \\\n                   nodeOrList.childNodes[index].tagName isnt 'BR'\n                    result += withBreaksAndTabs nodeOrList.childNodes[index]\n            result\n        wrapper = window.getTagData( tag, 'includeText' )\n        wrap = ( text ) ->\n            if not wrapper then return ''\n            if not tagData.hasOwnProperty wrapper then return text\n            result = \"<#{wrapper}>#{text}</#{wrapper}>\"\n            if alterXML = window.getTagData wrapper, 'alterXML'\n                result = alterXML result\n            result\n        result = if children.length\n            indent = ( text ) ->\n                \"  #{text.replace RegExp( '\\n', 'g' ), '\\n  '}\"\n            range = children[0].rangeBefore()\n            inner = ''\n            if not /^\\s*$/.test range.toString()\n                inner += wrap withBreaksAndTabs range\n            for child in children\n                if inner[inner.length-1] isnt '\\n' then inner += '\\n'\n                inner += \"#{window.convertToXML child}\\n\"\n                range = child.rangeAfter()\n                if not /^\\s*$/.test range.toString()\n                    inner += wrap withBreaksAndTabs range\n            \"<#{tag}>\\n#{indent inner}\\n</#{tag}>\"\n        else\n            text = if window.getTagData tag, 'rawXML'\n                if group?\n                    withBreaksAndTabs group.contentAsFragment()\n                else\n                    tinymce.activeEditor.getContent( format : 'text' ) \\\n                        .replace /\\xA0/g, '\\n'\n            else\n                tinymce.DOM.encode \\\n                    if group? then group.contentAsHTML() else \\\n                        tinymce.activeEditor.getContent()\n            wrapper ?= true\n            \"<#{tag}>#{wrap text}</#{tag}>\"\n        if alterXML = window.getTagData tag, 'alterXML'\n            result = alterXML result, group\n        result\n"]}