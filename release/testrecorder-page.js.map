{"version":3,"sources":["testrecorder-page.litcoffee"],"names":["installButtonClickHandlers","testState","update","waitingForMainApplication","waitingStorage","steps","window","enterWaitingState","toStore","document","body","childNodes","length","push","$","remove","innerHTML","enterReadyState","i","len","node","appendChild","args","ary","code","count","escapeApos","explanation","indent","index","ref","showComments","step","string","title","writeStep","is","console","log","codeString","line","results","split","text","replace","RegExp","type","content","shift","ctrl","alt","x","y","textContent","on","newTitle","prompt","opener","tinymce","activeEditor","getContent","result","alert","somethingIsTested","subject","slice","encodeURIComponent","Date","getElementById","location","href","editorKeyPress","keyCode","letter","String","fromCharCode","test","editorMouseClick","buttonClicked","name"],"mappings":"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","file":"testrecorder-page.js","sourcesContent":["\n# Test Recording UI\n\nLurch supports a mode in which it can record various keystrokes and\ncommand invocations, and store them in the form of code that can be copied\nand pasted into the source code for the app's unit testing suite.  This is\nvery handy for constructing new test cases without writing a ton of code.\nIt is also less prone to typographical and other small errors, since the\ncode is generated for you automatically.\n\nThat mode is implemented in two script files:\n * The file [testrecorder.litcoffee](#testrecorder.litcoffee), which pops up\n   a separate browser window that presents the test-recording UI.\n * This file, which implements all the UI interactivity in that popup\n   window.\n\n## Initializing global variables\n\nThe following variable stores the test state.\n\n    testState = steps : [ ]\n\nThis one marks us as waiting for the main application page to tell us that\nit's ready to talk to us.\n\n    waitingForMainApplication = yes\n\n## Protection against page reloading\n\nIf the user reloads this test recording page, it will return to its initial\nstate, even though the main application is not in its initial state.  This\nis undesirable, because the two must remain in sync.\n\nThus we create two functions, one that puts this page in a waiting state and\none that puts it into a ready state.  We enter the waiting state as soon as\nthe page is loaded, and the main application will use the second function to\nput us into the ready state as soon as it has finished loading.\n\n    waitingStorage = [ ]\n    window.enterWaitingState = ->\n        while document.body.childNodes.length > 0\n            toStore = document.body.childNodes[0]\n            waitingStorage.push toStore\n            ( $ toStore ).remove()\n        document.body.innerHTML =\n            'Waiting for main application page to load...<br>\n            (If you reloaded this window by itself, you done wrong.\n            Instead, close this window and reload the main application.)'\n    window.enterReadyState = ->\n        while document.body.childNodes.length > 0\n            ( $ document.body.childNodes[0] ).remove()\n        document.body.appendChild node for node in waitingStorage\n        installButtonClickHandlers()\n        update()\n    $ window.enterWaitingState\n\n## Update function\n\nThe update function fills the code output area with the in-code\nrepresentation of the `testState` global variable.\n\n    update = ->\n        code = ''\n        if not testState.title? and not testState.steps?\n            code = '(no steps recorded yet)'\n        else\n            showComments = ( $ '#showComments' ).is ':checked'\n            console.log ( $ '#showComments' ), showComments\n            writeStep = ( explanation, codeString ) ->\n                if showComments and explanation?\n                    code += \"\\n#{explanation}\\n\"\n                if codeString?\n                    if showComments and explanation? then code += '\\n'\n                    for line in codeString.split '\\n'\n                        code += \"        #{line}\\n\"\n            escapeApos = ( text ) -> text.replace /'/g, '\\\\\\''\n            indent = ( text ) ->\n                '    ' + text.replace ( RegExp '\\n', 'g' ), '\\n    '\n            code = '\\nTest built with Lurch test-recording mode.\\n\\n'\n            title = testState.title or 'untitled test'\n            code += \"    it '#{escapeApos title}', inPage ->\\n\"\n            ary = testState.steps\n            for step, index in ary\n                if index > 0 and ary[index].type is ary[index-1].type\n                    count = 0\n                else\n                    count = 1\n                    while ( index+count < ary.length ) and \\\n                          ( ary[index].type is ary[index+count].type )\n                        count++\n                if step.type is 'comment'\n                    writeStep step.content\n                else if step.type is 'check contents'\n                    string = \"'#{escapeApos step.content}'\"\n                    writeStep 'Check to be sure the editor contains the\n                        correct content.', \"pageExpects allContent, 'toBeSimilarHTML',\\n#{indent string}\"\n                else if step.type is 'wrong contents'\n                    string = \"'TO BE EDITED: #{escapeApos step.content}'\"\n                    writeStep \"At this point the editor contains incorrect\n                        contents.  (The code below will need to be edited\n                        later to replace the incorrect expectation with a\n                        correct one.)\\n\n                        \\nExplanation of how the expectation below is\n                        incorrect:  #{step.explanation}\",\n                        \"pageExpects allContent,\n                        'toBeSimilarHTML',\\n#{indent string}\"\n                else if step.type is 'key press'\n                    explanation = switch count\n                        when 0 then null\n                        when 1 then 'Simulate pressing a key in the editor.'\n                        else 'Simulate pressing keys in the editor.'\n                    args = \"'#{step.content}'\"\n                    if step.shift then args += \", 'shift'\"\n                    if step.ctrl then args += \", 'ctrl'\"\n                    if step.alt then args += \", 'alt'\"\n                    writeStep explanation, \"pageKey #{args}\"\n                else if step.type is 'typing'\n                    writeStep 'Simulate typing in the editor.',\n                        \"pageType '#{escapeApos step.content}'\"\n                else if step.type is 'click'\n                    writeStep 'Simulate a mouse click in the editor.',\n                        \"pageClick #{step.x}, #{step.y}\"\n                else if step.type is 'button'\n                    explanation = switch count\n                        when 0 then null\n                        when 1 then 'Simulate clicking a command button\n                            in the editor.'\n                        else 'Simulate clicking command buttons\n                            in the editor.'\n                    writeStep explanation,\n                        \"pageCommand '#{escapeApos step.content}'\"\n                else\n                    writeStep 'ERROR: Unknown step type:',\n                        \"'#{escapeApos step.type}'\\n# #{step.content}\"\n        document.getElementById( 'testCode' )?.textContent = code\n\nThe update function should be called as soon as the page has loaded.\n\n    $ update\n\n## Button click handlers\n\n    installButtonClickHandlers = ->\n\nWhen the user clicks the \"Set Test Title\" button, we prompt them for a\ntitle, then update the code in the output area to reflect the change.\n\n        ( $ '#setTitle' ).on 'click', ->\n            newTitle = prompt 'Enter new test title', testState.title ? ''\n            if newTitle isnt null\n                testState.title = newTitle\n                update()\n\nWhen the user clicks the \"Add a Comment\" button, we prompt them for its\ncontents, then add it to the steps array as a comment.\n\n        ( $ '#addComment' ).on 'click', ->\n            content = prompt 'Enter your comment here', ''\n            if content isnt null\n                testState.steps.push { type : 'comment', content : content }\n                update()\n\nWhen the user clicks the \"Call Editor Contents Correct\" button, we add a\nstep to the list of test steps, containing within it the full contents of\nthe editor as they stand.\n\n        ( $ '#contentsCorrect' ).on 'click', ->\n            testState.steps.push\n                type : 'check contents'\n                content : window.opener.tinymce.activeEditor.getContent()\n            update()\n\nWhen the user clicks the \"Call Editor Contents Incorrect\" button, we add a\nstep to the list of test steps, containing within it the full contents of\nthe editor as they stand, plus an explanation the user provides about why\nthe editor has incorrect contents.\n\n        ( $ '#contentsIncorrect' ).on 'click', ->\n            explanation = prompt 'Please provide an explanation of why the\n                editor\\'s contents are incorrect.  Include a suggestion of\n                what they ought to be, if possible.', ''\n            if explanation isnt null\n                testState.steps.push\n                    type : 'wrong contents'\n                    content :\n                        window.opener.tinymce.activeEditor.getContent()\n                    explanation : explanation\n                update()\n\nWhen the user clicks the \"See Editor Contents\" button, we pop up an alert\ndialog containing the editor contents for the user to view.\n\n        ( $ '#seeContents' ).on 'click', ->\n            result = window.opener.tinymce.activeEditor.getContent()\n            if result is '' then alert 'Editor is empty.'\n            else alert 'The editor contents are represented in HTML format\n                below.\\n\\n' + result\n\nWhen the user clicks the \"Email Generated Test to Developers\" button, we\ncreate an email-sending link and navigate to it.  However, if the current\ntest doesn't actually contain any calls to `pageExpects`, then we inform the\nuser that they haven't actually tested anything yet.\n\n        ( $ '#emailTest' ).on 'click', ->\n            somethingIsTested = no\n            for step in testState.steps\n                if step.type[-9..] is ' contents'\n                    somethingIsTested = yes\n                    break\n            if not somethingIsTested\n                alert 'You have not made any assertions yet in the test.\n                    You must at some point mark the editor contents as\n                    correct or incorrect in order for the generated code to\n                    actually contain an assertion to be tested.'\n                return\n            recipient = 'ncarter@bentley.edu'\n            subject = 'Lurch: recorded unit test'\n            body = encodeURIComponent \"\\n\n                \\nThe following unit test was recorded on #{new Date}.\\n\n                \\n(Before sending this email, feel free to add any extra\n                    information you have here.)\\n\n                \\n-----------begin test code------------\\n\n                #{document.getElementById( 'testCode' ).textContent}\"\n            window.location.href =\n                \"mailto:#{recipient}?subject=#{subject}&body=#{body}\"\n\nWhen the checkbox for whether to include comments in code changes, update\nthe generated code.\n\n        ( $ '#showComments' ).on 'change', ->\n            console.log 'checkbox changed'\n            update()\n\n## Events from the main page\n\nThe page with the editor in it will send us various events, such as key\npresses and menu clicks.  We will record them as part of the test using the\nhandlers provided below, which the main page calls.\n\n    window.editorKeyPress = ( keyCode, shift, ctrl, alt ) ->\n        letter = String.fromCharCode keyCode\n        if /[a-zA-Z0-9 ]/.test letter\n            if testState.steps.length > 0 and \\\n               testState.steps[testState.steps.length-1].type is 'typing'\n                testState.steps[testState.steps.length-1].content += letter\n            else\n                testState.steps.push\n                    type : 'typing'\n                    content : letter\n        else\n            testState.steps.push\n                type : 'key press'\n                content : keyCode\n                shift : shift\n                ctrl : ctrl\n                alt : alt\n        update()\n    window.editorMouseClick = ( x, y ) ->\n        testState.steps.push\n            type : 'click'\n            x : x\n            y : y\n        update()\n    window.buttonClicked = ( name ) ->\n        testState.steps.push\n            type : 'button'\n            content : name\n        update()\n"]}