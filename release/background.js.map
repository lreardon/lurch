{"version":3,"sources":["background.litcoffee"],"names":["BackgroundFunction","workerScript","bind","fn","me","apply","arguments","window","Background","functions","registerFunction","name","func","globals","scripts","function","runningTasks","waitingTasks","addTask","funcName","inputs","callback","i","index","input","inputToId","j","len","len1","newTask","ref","ref1","ref2","ref3","task","Group","id","JSON","stringify","results","length","splice","terminate","push","update","addCodeTask","available","B","data","runner","toStart","concurrency","shift","pop","cleanup","base","name1","indexOf","call","sendTo","result","orElse","Math","max","navigator","hardwareConcurrency","_Class","_function","globals1","scripts1","this","promise","_this","resultCallback","hasOwnProperty","errorCallback","error","Worker","worker","addEventListener","event","postMessage","setFunction","install","import","args","slice","deleted","toJSON","runOn","setTimeout","base1","e"],"mappings":"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","file":"background.js","sourcesContent":["    workerScript = 'data:text/javascript;base64,dmFyIGJ1aWxkRnVuY3Rpb24saGFzUHJvcD17fS5oYXNPd25Qcm9wZXJ0eTtidWlsZEZ1bmN0aW9uPWZ1bmN0aW9uKG4pe3ZhciB0LGE7cmV0dXJuIHQ9bi5zdWJzdHJpbmcobi5pbmRleE9mKCIoIikrMSxuLmluZGV4T2YoIikiKSksYT1uLnN1YnN0cmluZyhuLmluZGV4T2YoInsiKSsxLG4ubGFzdEluZGV4T2YoIn0iKSksbmV3IEZ1bmN0aW9uKHQsYSl9LHNlbGYud2luZG93PXNlbGYsc2VsZi5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIixmdW5jdGlvbihuKXt2YXIgdCxhLGk7aWYobi5kYXRhLmhhc093blByb3BlcnR5KCJzZXRGdW5jdGlvbiIpJiYoc2VsZi5hY3Rpb249YnVpbGRGdW5jdGlvbihuLmRhdGEuc2V0RnVuY3Rpb24pKSxuLmRhdGEuaGFzT3duUHJvcGVydHkoInJ1bk9uIikmJnNlbGYucG9zdE1lc3NhZ2UoImZ1bmN0aW9uIj09dHlwZW9mIHNlbGYuYWN0aW9uP3NlbGYuYWN0aW9uLmFwcGx5KHNlbGYsbi5kYXRhLnJ1bk9uKTp2b2lkIDApLG4uZGF0YS5oYXNPd25Qcm9wZXJ0eSgiaW5zdGFsbCIpKXtpPW4uZGF0YS5pbnN0YWxsO2ZvcihhIGluIGkpaGFzUHJvcC5jYWxsKGksYSkmJih0PWlbYV0sc2VsZlthXT1idWlsZEZ1bmN0aW9uKHQpKX1pZihuLmRhdGEuaGFzT3duUHJvcGVydHkoImltcG9ydCIpKXJldHVybiBpbXBvcnRTY3JpcHRzLmFwcGx5KG51bGwsbi5kYXRhLmltcG9ydCl9LCExKTsKLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29ya2VyLmpzLm1hcAo='\n\n\n# Background Computations\n\nThis module defines an API for enqueueing background computations on groups\nin Lurch.  It provides an efficient means for running those computations,\nno matter how numerous they might be, while keeping the UI responsive.\n\nWarning:  If you do background computation in your document, you may find\nthe user saving the document and exiting the editor (e.g., closing the\nbrowser tab) while your background computations are occurring.  When such a\nfile is later loaded by the user, it will be in whatever intermediate state\nit was left in by those pending background computations.  To solve this\nproblem, you may wish to implement the `saveMetadata` and `loadMetadata`\nfunctions in the [Storage plugin](../app/storageplugin.litcoffee).  For\nexample, while background processing is running, you might have the\n`saveMetadata` member include that fact in the metadata, so that when it is\nreloaded later, the appliaction knows to re-process its contents, rather\nthan trust that they are up-to-date.\n\n## Global Background object\n\nThe first object defined herein is the global `Background` object, which\nencapsulates all activity that will take place \"in the background.\"  This\nmeans that such activity, will not begin immediately, but will be queued for\nlater processing (possibly in a thread other than the main UI thread).  It\nis called `Background` because you should think of this as encapsulating the\nvery notion of running a job in the background.\n\n    window.Background =\n\nThe first public API this global object provides is a way to register script\nfunctions as jobs that can be run in the background.  This does not enqueue\na task for running; it simply gives a name to a function that can later be\nused in the background.  Code cannot be run in the backgorund unless it has\nfirst been added to this global library of background-runnable functions,\nusing this very API.\n\nThe optional third parameter is a dictionary of name-function pairs that\nwill be installed in the background function's namespace when it is used.\nIf the background function uses a Web Worker, these will be sent as strings\nto the worker for recreation into functions (so their environments will not\nbe preserved).  If the background function is executed in the main thread\n(in environments that don't support Web Workers), a `with` clause will be\nused to ensure that the functions are in scope.  In that case, environments\nare preserved.  So write your functions independent of environment.\n\nThe optional fourth parameter is an array of scripts to import into the web\nworker.  In a Web Worker implementation, these will be run using\n`importScripts`.  In a non-Web Worker implementation, these will do nothing;\nyou should ensure that these same scripts are already imported into the\nenvironment from which this function is being called.\n\n        functions : { }\n        registerFunction : ( name, func, globals = { }, scripts = [ ] ) ->\n            window.Background.functions[name] =\n                function : func\n                globals : globals\n                scripts : scripts\n\nThe second public API this global object provides is the `addTask` function,\nwhich lets you add a task to the background processing queue, to be handled\nas soon as earlier-added tasks are complete and resources are available.\n\nThe first parameter must be the name of a function that has been passed to\n`registerFunction`.  If the name has not been registered, this task will not\nbe added to the queue.  The second parameter must be a list of group objects\non which to perform the given computation.  The third parameter is the\ncallback function that will be called with the result when the computation\nis complete.\n\nKeep in mind that the goal should be for the registered function (whose name\nis provided here in `funcName`) to do the vast majority of the work of the\ncomputation, and that `callback` should simply take that result and store it\nsomewhere or report it to the user.  The `callback` will be executed in the\nUI thread, and thus must be lightweight.  The function whose name is\n`funcName` will be run in the background, and thus can have arbitrary\ncomplexity.\n\n        runningTasks : [ ]\n        waitingTasks : [ ]\n        addTask : ( funcName, inputs, callback ) ->\n\nWhen storing this task, we give it an ID unique to it.  Since each input may\nbe a `Group` instance or arbitrary static data amenable to JSON\nstringification we create the following function that forms a unique ID for\neach input.\n\n            inputToId = ( input ) ->\n                if input instanceof Group\n                    input.id()\n                else\n                    JSON.stringify input\n            newTask =\n                name : funcName\n                inputs : inputs\n                callback : callback\n                id : \"#{funcName},#{inputToId input for input in inputs}\"\n\nBefore we add the function to the queue, we filter the current \"waiting\"\nqueue so that any previous copy of this exact same computation (same\nfunction name and input group list) is removed.  (If there were such a one,\nit would mean that it had been enqueued before some change in the document,\nwhich necessitated recomputing the same values based on new data.  Thus we\nthrow out the old computation and keep the new, later one, since it may sit\nchronologically among a list of waiting-to-run computations in a way in\nwhich order is important.)  We only need to seek one such copy, since we\nfilter every time one is added, so there cannot be more than one.\n\n            for task, index in window.Background.waitingTasks\n                if task.id is newTask.id\n                    window.Background.waitingTasks.splice index, 1\n                    break\n\nThen repeat the same procedure with the currently running tasks, except also\ncall `terminate()` in the running task before deleting it.\n\n            for task, index in window.Background.runningTasks\n                if task.id is newTask.id\n                    task.runner?.worker?.terminate?()\n                    window.Background.runningTasks.splice index, 1\n                    break\n\nNow we can enqueue the task and call `update()` to possibly begin processing\nit.\n\n            window.Background.waitingTasks.push newTask\n            window.Background.update()\n\nSometimes we do not wish to register tasks with specific names in advance,\nbut simply send code to the background.  Thus we provide the following\nconvenience function, which takes all the parameters of `registerFunction`\nand `addTask` combined, except for the function name.  It registers a new\ntask and immediately executes it on the arguments provided.  The name of the\nnew task *is* the code; that is, the code to run is used twice, once as the\ntask and once as its name.\n\n        addCodeTask : ( func, inputs, callback,\n                        globals = { }, scripts = [ ] ) ->\n            window.Background.registerFunction \"#{func}\", func, globals,\n                scripts\n            window.Background.addTask \"#{func}\", inputs, callback\n\nThe update function just mentioned will verify that as many tasks as\npossible are running concurrently.  That number will be determined by [the\ncode below](#ideal-amount-of-concurrency).  The update function, however, is\nimplemented here.\n\n        available : { }\n        update : ->\n            B = window.Background\n            while B.runningTasks.length < B.concurrency()\n                if not ( toStart = B.waitingTasks.shift() )? then return\n\nIf we have a `BackgroundFunction` object that's not running, and is of the\nappropriate type, let's re-use it.  Otherwise, we must create a new one.\nEither way, add it to the running tasks list if we were able to create an\nappropriate `BackgroundFunction` instance.\n\n                runner = B.available[toStart.name]?.pop()\n                if not runner?\n                    data = B.functions[toStart.name]\n                    if not data? then continue\n                    runner = new BackgroundFunction data.function,\n                        data.globals, data.scripts\n                toStart.runner = runner\n                B.runningTasks.push toStart\n\nFrom here onward, we will be creating some callbacks, and thus need to\nprotect the variable `toStart` from changes in later loop iterations.\n\n                do ( toStart ) ->\n\nWhen the task completes, we will want to remove it from the list of running\ntasks and place `runner` on the `available` list for reuse.  Then we should\nmake another call to this very update function, in case the end of this task\nmakes possible the start of another task, within the limits of ideal\nconcurrency.\n\nWe define this cleanup function to do all that, so we can use\nit in two cases below.\n\n                    cleanup = ->\n                        index = B.runningTasks.indexOf toStart\n                        B.runningTasks.splice index, 1\n                        ( B.available[toStart.name] ?= [ ] ).push runner\n                        window.Background.update()\n\nStart the background process.  Call `cleanup` whether the task succeeds or\nhas an error, but only call the callback if it succeeds.\n\n                    runner.call( toStart.inputs... ).sendTo ( result ) ->\n                        cleanup()\n                        toStart.callback? result\n                    .orElse cleanup\n\n## Ideal amount of concurrency\n\nModern browsers (in particular, the target browser Chrome for this app)\nreport the number of cores available on the client in the value of\n`navigator.hardwareConcurrency`.\n\nWe then write the following function to compute the number of background\ntasks we should attempt to run concurrently.  It returns n-1, as described\nabove.  It rounds that value up to 1, however, in the event that the machine\nhas only 1 core.  Also, if the browser does not report a value for hardware\nconcurrency, it returns 1.\n\n    window.Background.concurrency = ->\n        Math.max 1, ( navigator?.hardwareConcurrency ? 1 ) - 1\n\n## `BackgroundFunction` class\n\nWe define the following class for encapsulating functions that are ready to\nbe run in the background.\n\n    BackgroundFunction = class\n\nThe constructor stores in the `@function` member the function that this\nobject is able to run in the background.\n\n        constructor : ( @function, @globals, @scripts ) ->\n\nThe promise object, which will be returned from the `call` member, permits\nchaining.  Thus all of its methods return the promise object itself.  There\nare only two methods, `sendTo`, for specifying the result callback, and\n`orElse`, for specifying the error callback.  Thus the use of the call\nmember looks like `bgfunc.call( args... ).sendTo( resultHandler ).orElse(\nerrorHandler )`.\n\n            @promise =\n                sendTo : ( callback ) =>\n                    @promise.resultCallback = callback\n                    if @promise.hasOwnProperty 'result'\n                        @promise.resultCallback @promise.result\n                    @promise\n                orElse : ( callback ) =>\n                    @promise.errorCallback = callback\n                    if @promise.hasOwnProperty 'error'\n                        @promise.errorCallback @promise.error\n                    @promise\n\nIf Web Workers are supported in the current environment, we create one for\nthis background function.  Otherwise, we do not, and we will have to fall\nback on a much simpler technique later.  When we load the worker script, we\nuse jQuery to find out the URL from which this script itself was loaded, and\nget the worker script from the same location.  This enables easier use from\na CDN.\n\n            if window.Worker\n                @worker = new window.Worker     workerScript\n                @worker.addEventListener 'message', ( event ) =>\n                    @promise.result = event.data\n                    @promise?.resultCallback? event.data\n                , no\n                @worker.addEventListener 'error', ( event ) =>\n                    @promise.error = event\n                    @promise?.errorCallback? event\n                , no\n                @worker.postMessage setFunction : \"#{@function}\"\n                for own name, func of @globals\n                    @globals[name] = \"#{func}\"\n                @worker.postMessage install : @globals\n                @worker.postMessage import : @scripts\n\nBackground functions need to be callable.  Calling them returns the promise\nobject defined in the constructor, into which we can install callbacks for\nwhen the result is computed, or when an error occurs.\n\n        call : ( args... ) =>\n\nFirst, clear out any old data in the promise object from a previous call of\nthis background function.\n\n            delete @promise.result\n            delete @promise.resultCallback\n            delete @promise.error\n            delete @promise.errorCallback\n\nSecond, prepare all arguments (which may be Group objects or static data\namenable to JSON stringification) for use in the worker thread by\nserializing them.  If any of the groups on which we should run this function\nhave been deleted since it was created, we quit and do nothing.\n\n            for input in args\n                if input instanceof Group and input.deleted then return\n\nWhen Web Workers are used, we must first serialize each group passed to the\nweb worker, because it cannot be passed as is, containing DOM objects.  So\nwe do that in both cases, so that functions can be consistent, and not need\nto know whether they're running in a worker or not.\n\n            inputs = for input in args\n                if input instanceof Group then input.toJSON() else input\n\nRun the computation soon, but not now.  When it is run, store the result or\nerror in the promise, and call the result or error handler, whichever is\nappropriate, assuming it has been defined by then.  If it hasn't been\ndefined at that time, the result/error will be stored and set to the result\nor error callback the moment one is registered, using one of the two\nfunctions defined above, in the promise object.\n\nIf Web Workers are supported, we use the one constructed in this object's\nconstructor.  If not, we fall back on simply using a zero timer, the poor\nman's \"background\" processing.\n\n            if @worker?\n                @worker.postMessage runOn : inputs\n            else\n                setTimeout =>\n                    try\n                        `with ( this.globals ) {`\n                        @promise.result = @function inputs...\n                        `}`\n                    catch e\n                        @promise.error = e\n                        @promise.errorCallback? @promise.error\n                        return\n                    @promise.resultCallback? @promise.result\n                , 0\n\nReturn the promise object, for chaining.\n\n            @promise\n"]}